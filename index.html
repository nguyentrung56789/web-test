<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>B·∫£n ƒë·ªì kh√°ch h√†ng ‚Äî CSV c√¥ng khai + l·ªçc nhi·ªÅu ƒëi·ªÅu ki·ªán</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
<script src="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root { --border:#e5e7eb; --muted:#6b7280; }
  html,body{height:100%;margin:0}
  body{font-family:system-ui,Segoe UI,Roboto,Arial}
  #toolbar{position:sticky;top:0;z-index:10;display:flex;gap:8px;align-items:center;padding:8px;border-bottom:1px solid var(--border);background:#fff}
  #toolbar .grow{flex:1}
  #map{height:calc(100% - 56px)}
  button{padding:8px 12px;border:1px solid #d0d7de;border-radius:10px;background:#fff;cursor:pointer}
  input[type="text"]{padding:8px 12px;border:1px solid #d0d7de;border-radius:10px;width:100%}
  label{user-select:none;white-space:nowrap}
  .muted{color:var(--muted);font-size:12px}
  details{margin-left:8px}
  summary{cursor:pointer}
  pre{white-space:pre-wrap}
</style>
</head>
<body>
  <div id="toolbar">
    <button id="reload">T·∫£i l·∫°i</button>
    <button id="export">Xu·∫•t CSV</button>
    <div class="grow"><input id="q" type="text" placeholder="T√¨m: ma: KH0001 KH0002, ten: an l√£o, sdt: 098..., ho·∫∑c g√µ t·ª´ kho√° t·ª± do..." /></div>
    <label><input id="vnOnly" type="checkbox" checked> Ch·ªâ VN</label>
    <span id="status" class="muted">S·∫µn s√†ng</span>
    <details><summary>Chi ti·∫øt</summary>
      <pre id="debug" style="max-height:40vh;overflow:auto;margin:0"></pre>
    </details>
  </div>
  <div id="map"></div>

<script>
/* ================== C·∫§U H√åNH ================== */
/* CSV c√¥ng khai c·ªßa b·∫°n (Publish to web ‚Üí CSV) */
const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQFLOQCFAQqdcQLP4Yxy0IAVk2f1GCs3nTpEdrITr5s47wOAdViQ3K0VkcQLQSRoLehUe8jFfXrvjkm/pub?output=csv";

/* Bi√™n Vi·ªát Nam (n·ªõi nh·∫π) + t√¢m map */
const VN_BOX    = { latMin: 7, latMax: 25, lngMin: 100, lngMax: 112 };
const VN_CENTER = { lat: 16.2, lng: 107.8 };

/* ================== MAP ================== */
const map = L.map('map', {
  preferCanvas: true,
  maxBounds: [[VN_BOX.latMin,VN_BOX.lngMin],[VN_BOX.latMax,VN_BOX.lngMax]],
  maxBoundsViscosity: 0.6
}).setView([VN_CENTER.lat, VN_CENTER.lng], 6);

L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap'
}).addTo(map);

const cluster = L.markerClusterGroup({ chunkedLoading: true });
map.addLayer(cluster);

/* ================== HELPERS ================== */
const $ = id => document.getElementById(id);
const state = { rows: [], stats: null };

function setStatus(s){ $('status').textContent = s; }
function logDebug(v){ $('debug').textContent = (typeof v==='string')? v : JSON.stringify(v,null,2); }

function inVN(lat,lng){ return lat>=VN_BOX.latMin && lat<=VN_BOX.latMax && lng>=VN_BOX.lngMin && lng<=VN_BOX.lngMax; }
function d2VN(lat,lng){ const dx=lat-VN_CENTER.lat, dy=lng-VN_CENTER.lng; return dx*dx+dy*dy; }

/* Chu·∫©n ho√° s·ªë: "1.065.568.824", "20,7256", "2072567"... ‚Üí Number */
function toNumSmart(x){
  if (typeof x==='number') return x;
  if (x==null) return NaN;
  let s = String(x).trim();

  // d·∫°ng 1.234.567,89 -> 1234567.89
  if (/^\d{1,3}(\.\d{3})+(,\d+)?$/.test(s)) s = s.replace(/\./g,'').replace(',', '.');

  // gi·ªØ s·ªë, d·∫•u ch·∫•m, ph·∫©y, √¢m
  s = s.replace(/[^\d\.\,\-]/g,'');

  // c√≥ c·∫£ . v√† , : chu·∫©n ho√° theo v·ªã tr√≠ cu·ªëi
  if (s.includes('.') && s.includes(',')) {
    if (s.lastIndexOf(',') < s.lastIndexOf('.')) s = s.replace(/,/g,''); // 1,234.56
    else s = s.replace(/\./g,'').replace(',', '.');                      // 1.234,56
  } else if (s.includes(',')) s = s.replace(',', '.');

  const n = Number(s);
  return Number.isFinite(n)? n : NaN;
}

/* Th·ª≠ nhi·ªÅu thang s·ªë + ƒë·∫£o c·ªôt (ƒë·ªÉ s·ª≠a E5/E6/E7 v√† nh·∫ßm lat/lng) */
const SCALES = [1, 1e5, 1e6, 1e7];
function bestFix(aRaw, bRaw){
  const a = toNumSmart(aRaw), b = toNumSmart(bRaw);
  const cand = [];
  function push(lat,lng,label){
    if(Number.isFinite(lat) && Number.isFinite(lng) && Math.abs(lat)<=90 && Math.abs(lng)<=180){
      cand.push({lat:+lat.toFixed(6), lng:+lng.toFixed(6), inside: inVN(lat,lng), d2: d2VN(lat,lng), label});
    }
  }
  for (const k of SCALES){
    // coi a=lng, b=lat (GeoJSON) ‚Üí Leaflet d√πng [lat,lng]
    push(b/k, a/k, `geo_${k}`);
    // coi a=lat, b=lng (ƒë·∫£o c·ªôt)
    push(a/k, b/k, `swap_${k}`);
  }
  if (!cand.length) return null;
  cand.sort((p,q)=>{
    if (p.inside !== q.inside) return q.inside ? 1 : -1; // ∆∞u ti√™n trong VN
    if (p.d2 !== q.d2) return p.d2 - q.d2;               // g·∫ßn VN h∆°n
    return 0;
  });
  return cand[0];
}

/* Popup */
function esc(s){ return String(s??'').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function makePopup(r){
  const mt = String(r.mo_ta||'').replace(/<br\s*\/?>/gi,'\n').replace(/\n/g,'<br>');
  return `<div style="min-width:240px">
    <b>${esc(r.ten||'(kh√¥ng t√™n)')}</b><br>
    ${r.ma_kh?`<span class="muted">${esc(r.ma_kh)}</span><br>`:''}
    ${r.dia_chi?`üìç ${esc(r.dia_chi)}<br>`:''}
    ${r.dien_thoai?`‚òéÔ∏è ${esc(r.dien_thoai)}<br>`:''}
    ${mt?`<div style="margin-top:6px">${mt}</div>`:''}
    <div style="margin-top:6px"><a target="_blank" href="https://www.google.com/maps?q=${r.lat},${r.lng}">M·ªü Google Maps</a></div>
  </div>`;
}

/* V·∫Ω */
function render(rows){
  const vnOnly = $('vnOnly').checked;
  cluster.clearLayers();
  const bounds = []; let kept = 0;

  for (const r of rows){
    if(!Number.isFinite(r.lat) || !Number.isFinite(r.lng)) continue;
    if(vnOnly && !inVN(r.lat,r.lng)) continue;
    kept++;
    const m = L.marker([r.lat, r.lng]).bindPopup(makePopup(r));
    cluster.addLayer(m); bounds.push([r.lat, r.lng]);
  }
  if(bounds.length) map.fitBounds(L.latLngBounds(bounds).pad(0.1));
  else map.setView([VN_CENTER.lat, VN_CENTER.lng], 6);

  setStatus(`V·∫Ω ${kept}/${rows.length} ƒëi·ªÉm`);
}

/* ƒêo√°n t√™n c·ªôt lat/lng & chu·∫©n ho√° */
function normalizeCSVRows(rows){
  const guessKey = (obj, alts)=>Object.keys(obj).find(k=>alts.includes(k.toLowerCase().trim()));
  const LAT_KEYS = ['lat','vƒ© ƒë·ªô','vido','vi_do','latitude','y','vi do'];
  const LNG_KEYS = ['lng','lon','kinh ƒë·ªô','kinhdo','kinh_do','longitude','x','kinh do'];

  const out=[]; let dropped=0;
  for (const r of rows){
    const latKey = guessKey(r, LAT_KEYS) || 'lat';
    const lngKey = guessKey(r, LNG_KEYS) || 'lng';

    const latRaw = r[latKey], lngRaw = r[lngKey];
    const pick = bestFix(lngRaw, latRaw) || bestFix(latRaw, lngRaw);
    if (!pick) { dropped++; continue; }

    out.push({
      ma_kh: r.ma_kh||r['ma kh']||'',
      ten: r.ten||'',
      dia_chi: r.dia_chi||r['dia chi']||'',
      dien_thoai: r.dien_thoai||r['dien thoai']||r['sdt']||'',
      mo_ta: r.mo_ta||'',
      lat: pick.lat, lng: pick.lng
    });
  }
  return {rows: out, drop: dropped};
}

/* T·∫£i CSV */
async function loadCSV(){
  try{
    setStatus('ƒêang t·∫£i CSV‚Ä¶');
    const res = await fetch(CSV_URL + '&cache=' + Date.now(), {cache:'no-store'});
    const text = await res.text();
    if (!text || !/[,;\n]/.test(text)) { setStatus('CSV r·ªóng/kh√¥ng h·ª£p l·ªá'); logDebug(text.slice(0,300)); return; }

    const parsed = Papa.parse(text, {header:true, skipEmptyLines:true});
    if (parsed.errors && parsed.errors.length){
      setStatus('L·ªói parse CSV'); logDebug(parsed.errors.slice(0,3)); return;
    }

    const norm = normalizeCSVRows(parsed.data);
    state.rows = norm.rows;
    state.stats = { total: parsed.data.length, valid: norm.rows.length, dropped: norm.drop };

    render(state.rows);
    logDebug({stats:state.stats, sample:state.rows.slice(0,3), preview:text.slice(0,300)});
  }catch(err){
    setStatus('L·ªói t·∫£i CSV: ' + err.message);
    logDebug(String(err));
  }
}

/* Xu·∫•t CSV sau khi chu·∫©n ho√° */
function exportCsv(rows, filename='khach_hang_clean.csv'){
  const headers = ['ma_kh','ten','dia_chi','dien_thoai','mo_ta','lat','lng'];
  const csv = [headers.join(',')].concat(rows.map(r =>
    headers.map(k => '"' + String(r[k]??'').replace(/"/g,'""') + '"').join(',')
  )).join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}

// ---- THAY parseQuery & rowMatches B·∫∞NG ƒêO·∫†N N√ÄY ----
function parseQuery(q) {
  const out = { any: [], ma: [], ten: [], dc: [], sdt: [] };
  let cur = null; // ƒëang nh·∫≠p cho key n√†o (ma|ten|dc|sdt)

  // t√°ch theo kho·∫£ng tr·∫Øng / d·∫•u ph·∫©y / ch·∫•m ph·∫©y
  for (const raw of q.split(/[,\s;]+/)) {
    const tok = raw.trim();
    if (!tok) continue;

    // 1) Tr∆∞·ªùng h·ª£p "ma:" ƒë·ª©ng 1 m√¨nh -> chuy·ªÉn tr·∫°ng th√°i
    let m = tok.match(/^(ma|ten|dc|sdt):$/i);
    if (m) { cur = m[1].toLowerCase(); continue; }

    // 2) Tr∆∞·ªùng h·ª£p "ma:KH0001" (c√≥ gi√° tr·ªã ngay sau d·∫•u :)
    m = tok.match(/^(ma|ten|dc|sdt):(.*)$/i);
    if (m) {
      cur = m[1].toLowerCase();
      const val = m[2].trim();
      if (val) out[cur].push(val.toLowerCase());
      continue;
    }

    // 3) Kh√¥ng c√≥ ti·ªÅn t·ªë -> n·∫øu ƒëang ·ªü mode "cur" th√¨ th√™m v√†o key ƒë√≥,
    //    c√≤n kh√¥ng th√¨ coi l√† t·ª´ kh√≥a t·ª± do (AND)
    if (cur) out[cur].push(tok.toLowerCase());
    else out.any.push(tok.toLowerCase());
  }
  return out;
}

function rowMatches(r, f) {
  const sAll = `${r.ma_kh||''} ${r.ten||''} ${r.dia_chi||''} ${r.dien_thoai||''} ${r.mo_ta||''}`.toLowerCase();
  const ma  = (r.ma_kh||'').toLowerCase();
  const ten = (r.ten||'').toLowerCase();
  const dc  = (r.dia_chi||'').toLowerCase();
  const sdt = (r.dien_thoai||'').toLowerCase();

  // V·ªõi c√°c m·∫£ng theo key: ch·ªâ c·∫ßn TR√ôNG √çT NH·∫§T 1 ph·∫ßn t·ª≠ (OR)
  if (f.ma.length  && !f.ma.some(x => ma.includes(x)))  return false;
  if (f.ten.length && !f.ten.some(x => ten.includes(x))) return false;
  if (f.dc.length  && !f.dc.some(x  => dc.includes(x)))  return false;
  if (f.sdt.length && !f.sdt.some(x => sdt.includes(x))) return false;

  // T·ª´ kho√° t·ª± do: T·∫§T C·∫¢ ph·∫£i kh·ªõp (AND)
  if (f.any.length && !f.any.every(x => sAll.includes(x))) return false;

  return true;
}
// ---- H·∫æT PH·∫¶N THAY TH·∫æ ----


/* S·ª± ki·ªán */
$('reload').addEventListener('click', loadCSV);
$('vnOnly').addEventListener('change', ()=>render(state.rows));
$('q').addEventListener('input', e=>{
  const q = e.target.value.trim();
  if (!q){ render(state.rows); return; }
  const filter = parseQuery(q);
  const rs = state.rows.filter(r => rowMatches(r, filter));
  render(rs);
});
$('export').addEventListener('click', ()=>{
  if(!state.rows.length) return alert('Ch∆∞a c√≥ d·ªØ li·ªáu.');
  exportCsv(state.rows);
});

/* T·ª± ch·∫°y */
loadCSV();
</script>
</body>
</html>
